#!/usr/bin/env python
#
# Create job arrays from template files and parameter values provided on
# the command line.
#

import sys
import os
import re
import argparse
import logging
import errno
import StringIO
import contextlib
import json

#
# The Scriptlet class is used to execute Python code found in the
# template files:
#
@contextlib.contextmanager
def stdoutIO(stdout=None):
    old = sys.stdout
    if stdout is None:
        stdout = StringIO.StringIO()
    sys.stdout = stdout
    yield stdout
    sys.stdout = old

class Scriptlet(object):

    def __init__(self, codeString, globalVars = {}, localVars = {}):
        self._codeString = codeString
        self._globalVars = globalVars
        self._localVars = localVars
        self._output = None
        self._hasBeenExecuted = False
        self._didProduceError = False

    def execute(self):
        self._hasBeenExecuted = True
        self._didProduceError = False
        self._output = None
        try:
            with stdoutIO() as s:
                exec(self._codeString, self._globalVars, self._localVars)
            self._output = s.getvalue()
        except Exception as E:
            self._output = str(E)
            self._didProduceError = True
        return not self._didProduceError

    def globalVars(self):
        return self._globalVars.viewitems()

    def localVars(self):
        return self._localVars.viewitems()

    def hasBeenExecuted(self):
        return self._hasBeenExecuted

    def didProduceError(self):
        return self._didProduceError

    def output(self):
        return self._output


class TemplateCache(object):

    _cached_content = dict()

    @classmethod
    def getTemplateContent(cls, path):
        if path != '-':
            path = os.path.abspath(path)
        if path in cls._cached_content:
            return '' + cls._cached_content[path]
        logging.debug('initial read of template %s', path)
        if path == '-':
            content = sys.stdin.read()
        else:
            input_stream = open(path, 'r')
            content = input_stream.read()
            input_stream.close()
        cls._cached_content[path] = content
        return content


#
# Define our parameter list class:
#
class Parameter(object):

    __float_range_regex_str = r'(([+-]?\d+(\.\d*)?(e[+-]?\d+)?)(-([+-]?\d+(\.\d*)?(e[+-]?\d+)?)(/\d+|:[+-]?\d+(\.\d*)?))?)'
    __float_range_regex = re.compile('^'+__float_range_regex_str+'$')
    __float_range_list_regex = re.compile('^'+__float_range_regex_str+'(,'+__float_range_regex_str+')*$')

    __int_range_regex_str = r'(([+-]?\d+)(-([+-]?\d+)(/\d+|:[+-]?\d+)?)?)'
    __int_range_regex = re.compile('^'+__int_range_regex_str+'$')
    __int_range_list_regex = re.compile('^'+__int_range_regex_str+'((,'+__int_range_regex_str+')*)$')

    def __init__(self, parameter_name, parameter_value_string):
        # Check the parameter name:
        parameter_name = parameter_name.strip()
        if not parameter_name:
            raise ValueError('no name provided for parameter value: %s', parameter_value_string)
        self.parameter_name = parameter_name
        self.value_list = list()

        # Check the format:
        m = Parameter.__int_range_list_regex.match(parameter_value_string)
        if m is not None:
            # Integer ranges:
            for range in parameter_value_string.split(','):
                m = Parameter.__int_range_regex.match(range)
                #
                # Groups:
                #    2      start value
                #    4      end value
                #    5      step function
                #
                start_value = int(m.group(2))
                end_value = m.group(4)
                if end_value is not None:
                    end_value = int(end_value)
                    if start_value != end_value:
                        step = m.group(5)
                        if step is None or step[0] == ':':
                            #
                            # Range with step size:
                            #
                            if step is None:
                                inc = None
                            else:
                                inc = int(step[1:])
                            if start_value > end_value:
                                # Descending, so inc must be negative:
                                if inc is None:
                                    inc = -1
                                elif inc >= 0:
                                    raise ValueError('descending integer range requires negative non-zero step size')
                                while start_value >= end_value:
                                    if start_value not in self.value_list: self.value_list.append(start_value)
                                    start_value = start_value + inc
                            else:
                                # Ascending, so inc must be positive:
                                if inc is None:
                                    inc = 1
                                elif inc <= 0:
                                    raise ValueError('ascending integer range requires positive non-zero step size')
                                while start_value <= end_value:
                                    if start_value not in self.value_list: self.value_list.append(start_value)
                                    start_value = start_value + inc

                        elif step[0] == '/':
                            #
                            # Range divided into N values:
                            #
                            n_values = int(step[1:])
                            if n_values <= 1:
                                raise(ValueError('invalid integer range divisor: %d', n_values))

                            step = (end_value - start_value) / (n_values - 1)
                            if step == 0:
                                step = 1 if (end_value >= start_value) else -1

                            if start_value > end_value:
                                # Descending:
                                while start_value >= end_value:
                                    if start_value not in self.value_list: self.value_list.append(start_value)
                                    start_value = start_value + step
                            else:
                                # Ascending, so inc must be positive:
                                while start_value <= end_value:
                                    if start_value not in self.value_list: self.value_list.append(start_value)
                                    start_value = start_value + step

                        else:
                            raise ValueError('invalid integer range: %s', range)

                    else:
                        if start_value not in self.value_list: self.value_list.append(start_value)
                else:
                    if start_value not in self.value_list: self.value_list.append(start_value)
        else:
            m = Parameter.__float_range_list_regex.match(parameter_value_string)
            if m is not None:
                # Float ranges:
                for range in parameter_value_string.split(','):
                    m = Parameter.__float_range_regex.match(range)
                    #
                    # Groups:
                    #    2      start value
                    #    6      end value
                    #    9      step function
                    #
                    start_value = float(m.group(2))
                    end_value = m.group(6)
                    if end_value is not None:
                        end_value = float(end_value)
                        if start_value != end_value:
                            step = m.group(9)
                            if step is None or step[0] == ':':
                                #
                                # Range with step size:
                                #
                                if step is None:
                                    inc = None
                                else:
                                    inc = float(step[1:])
                                if start_value > end_value:
                                    # Descending, so inc must be negative:
                                    if inc is None:
                                        inc = -1.0
                                    elif inc >= 0:
                                        raise ValueError('descending float range requires negative non-zero step size')
                                    while start_value >= end_value:
                                        if start_value not in self.value_list: self.value_list.append(start_value)
                                        start_value = start_value + inc
                                else:
                                    # Ascending, so inc must be positive:
                                    if inc is None:
                                        inc = 1.0
                                    elif inc <= 0:
                                        raise ValueError('ascending float range requires positive non-zero step size')
                                    while start_value <= end_value:
                                        if start_value not in self.value_list: self.value_list.append(start_value)
                                        start_value = start_value + inc

                            elif step[0] == '/':
                                #
                                # Range divided into N values:
                                #
                                n_values = int(step[1:])
                                if n_values <= 1:
                                    raise(ValueError('invalid float range divisor: %d', n_values))

                                step = (end_value - start_value) / (n_values - 1)
                                if step == 0.0:
                                    step = 1.0 if (end_value >= start_value) else -1.0

                                if start_value > end_value:
                                    # Descending:
                                    while start_value >= end_value:
                                        if start_value not in self.value_list: self.value_list.append(start_value)
                                        start_value = start_value + step
                                else:
                                    # Ascending, so inc must be positive:
                                    while start_value <= end_value:
                                        if start_value not in self.value_list: self.value_list.append(start_value)
                                        start_value = start_value + step

                            else:
                                raise ValueError('invalid float range: %s', range)

                        else:
                            if start_value not in self.value_list: self.value_list.append(start_value)
                    else:
                        if start_value not in self.value_list: self.value_list.append(start_value)
            else:
                # List of strings:
                while len(parameter_value_string):
                    # Starts with quote?
                    if parameter_value_string[0] == '"' or parameter_value_string[0] == "'":
                        quote_char = parameter_value_string[0]
                        start_index = end_index = 1
                        found_end_quote = False
                        while end_index < len(parameter_value_string):
                            if parameter_value_string[end_index] == quote_char:
                                if last_char is None or last_char != '\\':
                                    # End of quoting:
                                    found_end_quote = True
                                    break
                            last_char = parameter_value_string[end_index]
                            end_index = end_index + 1
                        # End quote not found?
                        if not found_end_quote:
                            raise ValueError('invalid string value:  no ending quote: %s', parameter_value_string)
                        next_index = end_index + 1
                    else:
                        # No quotes, just find next comma:
                        start_index = 0
                        end_index = parameter_value_string.find(',')
                        if end_index == -1:
                            end_index = len(parameter_value_string)
                            next_index = end_index
                        else:
                            next_index = end_index + 1

                    self.value_list.append(parameter_value_string[start_index:end_index])
                    if next_index < len(parameter_value_string) and parameter_value_string[next_index] == ',':
                        parameter_value_string = parameter_value_string[next_index + 1:]
                    else:
                        parameter_value_string = parameter_value_string[next_index:]



def processInputTemplate(template_string, global_variables):
    """
    This function  scans through the incoming template string searching for blocks delimited by the "[{%" and "%}]"
    strings.  The contents of this block are expected to be Python code, which will be executed in a unique
    execution context populated with the given dictionary of global variables defining the input parameters.  A
    common local variable space is shared between all code blocks, so it is possible to calculate values that
    subsequent blocks will reference.  The local variable space starts out empty on each invocation of this
    function.

    If all is successful, the transformed template string is returned to the caller.  Otherwise, an exception
    will be raised describing the problem encountered.
    """
    try:
        searchFrom = 0
        global_variables_copy = dict(global_variables)
        local_variables = {}
        while ( True ):
            # Where's the next code block start?
            codeStart = template_string.find('[{%', searchFrom)
            if codeStart < 0:
                break

            # Where's the code block stop?
            codeEnd = template_string.find('%}]', codeStart)
            if codeEnd < 0:
                raise RuntimeError('unterminated code block in template')

            # Extract the code:
            code = template_string[codeStart + 3:codeEnd].strip()
            wholeLine = False
            if (codeStart == 0) or (template_string[codeStart - 1] == "\n"):
                # If this line was the first line OR the code block was preceded by a <NL>,
                # then we're possibly looking at a whole-line block.
                #
                # If the only characters following the code block are whitespace terminated by
                # a <NL>, then indicate as much and adjust the codeEnd index to be past that
                # terminal <NL> character.
                i = codeEnd + 3
                while i < len(template_string) and (template_string[i] <> "\n" and template_string[i].isspace()):
                    i = i + 1
                if template_string[i] == "\n":
                    codeEnd = i + 1
                    wholeLine = True
                else:
                    codeEnd = codeEnd + 3
            else:
                codeEnd = codeEnd + 3

            # Execute it:
            s = Scriptlet(code, global_variables_copy, local_variables)
            if not s.execute():
                raise RuntimeError('unable to execute code block (' + s.output() + '): ' + code)
            replacement = s.output()
            if not wholeLine:
                replacement = replacement.strip()

            # Replace the code:
            searchFrom = codeStart + len(replacement)
            if wholeLine:
                # If we're replacing a whole line, then an empty replacement sees the line being
                # removed entirely.  For a non-empty replacement, add the text plus a terminal <NL>
                # character:
                if replacement:
                    template_string = template_string[:codeStart] + replacement + template_string[codeEnd:]
                else:
                    template_string = template_string[:codeStart] + template_string[codeEnd:]
            else:
                # Simple replacment of an inline (not whole-line) code block:
                template_string = template_string[:codeStart] + replacement + template_string[codeEnd:]

        # All done:
        return template_string
    except Exception as E:
        raise RuntimeError('unable to generate job script template: ' + str(E))


TEMPLATING_OPTIONS_SHOULD_IGNORE_ERRORS = 1


def __writeInputTemplates(input_templates, global_variables, job_array_index, options, catalog_stream):
    for input_template in input_templates:
        # Get job index working directory setup:
        global_variables['JOB_ARRAY_INDEX'] = job_array_index
        try:
            logging.debug('processing template %s', input_template)
            templated_content = TemplateCache.getTemplateContent(input_template)
            templated_content = processInputTemplate(templated_content, global_variables)
            output_path = TemplatePathHelper.templatePathToOutputPath(input_template, job_array_index)
            logging.debug('  writing generated content to %s', output_path)
            output_stream = open(output_path, 'w')
            output_stream.write(templated_content)
            output_stream.close()
            global_variables.pop('JOB_ARRAY_INDEX', None)
            if catalog_stream:
                logging.debug('  updating indexing catalog for job array index %d', job_array_index)
                catalog_stream.write('[{0:d}:{1:s}] {2:s}\n'.format(job_array_index, output_path, json.dumps(global_variables, separators=(',',':'))))
            job_array_index = job_array_index + 1
        except Exception as E:
            logging.error('failed to generate %s for job array index %d: %s', input_template, job_array_index, str(E))
            if (options & TEMPLATING_OPTIONS_SHOULD_IGNORE_ERRORS) == 0:
                sys.exit(1)
    return job_array_index


def processInputTemplates(input_templates, global_variables, parameters, job_array_index=1, options=0, catalog_stream=None):
    """
    This recursive function pops the first Parameter off the parameters list and loops over it,
    calling this function with each value set in the variables list and passing the now-smaller
    parameters list.  If, however, the parameters list is empty after popping the top element,
    the processInputTemplate() function is called on each of the input_templates.
    """
    if len(parameters) > 0:
        parameter = parameters[0]
        remaining_parameters = parameters[1:]
        if len(remaining_parameters) > 0:
            # Recurse down into the next parameter:
            for pval in parameter.value_list:
                global_variables[parameter.parameter_name] = pval
                job_array_index = processInputTemplates(input_templates,
                	                                    global_variables,
                	                                    remaining_parameters,
                	                                    job_array_index=job_array_index,
                	                                    options=options,
                	                                    catalog_stream=catalog_stream)
            global_variables.pop(parameter.parameter_name, None)
        else:
            # No more parameters, time to process the template files:
            for pval in parameter.value_list:
                global_variables[parameter.parameter_name] = pval
                job_array_index = __writeInputTemplates(input_templates, global_variables, job_array_index, options, catalog_stream)
            global_variables.pop(parameter.parameter_name, None)
    else:
        # We get here if all of the parameters were single-valued:
        job_array_index = __writeInputTemplates(input_templates, global_variables, job_array_index, options, catalog_stream)
    return job_array_index




# Setup a map of logging levels to integer indices, and the index of the default:
log_level_map = ( logging.CRITICAL, logging.ERROR, logging.WARNING, logging.INFO, logging.DEBUG )
default_log_level = 1

# Define the CLI arguments we accept:
cli_parser = argparse.ArgumentParser(
                        description='generate templated job arrays',
                        epilog='A <param-spec> consists of <param-name>=<value-list>, where <param-name> uses any characters except equals (=).  The <value-list> is a comma-separated list of integer/float values; comma-separated list of integer/float ranges with optional step size (:1 or :1.5) or division count (/10); or comma-separated list of strings, optionally quote delimited.  ')
cli_parser.add_argument('--version',
                        action='version',
                        version='%(prog)s 0.0.1a')
cli_parser.add_argument('--verbose', '-v',
                        dest='verbose_level',
                        default=0,
                        action='count',
                        help='increase the amount of output produced as this program executes')
cli_parser.add_argument('--quiet', '-q',
                        dest='quiet_level',
                        default=0,
                        action='count',
                        help='decrease the amount of output produced as this program executes')
cli_parser.add_argument('--parameter', '-p',
                        metavar='<param-spec>',
                        dest='parameters',
                        action='append',
                        help='add a named parameter to the scan; if the parameter has a single value no scan is implied')
cli_parser.add_argument('--catalog', '-c',
                        metavar='<filepath>',
                        dest='catalog_path',
                        help='filename to which the indexing catalog (that maps job array index to parameter values) should be written; use "-" to write the index to stdout, if not specified then no index is written')
cli_parser.add_argument('--array-index', '-a',
                        metavar='<integer>',
                        dest='array_index',
                        type=int,
                        default=1,
                        help='starting index for the job array')
cli_parser.add_argument('--use-flat-layout', '-f',
                        dest='use_flat_layout',
                        action='store_true',
                        default=False,
                        help='do not create subdirectories for each job array index, put all files in the current directory')
cli_parser.add_argument('--directory-prefix', '-P',
                        metavar='<prefix>',
                        dest='directory_prefix',
                        default='./',
                        help='when using the subdirectory for each job array index, prefix this string on the job array index; e.g. for "-P ./JOB_" the directories ./JOB_1, ./JOB_2, etc. would be generated')
cli_parser.add_argument('--index-format-in-paths',
                        metavar='<python-conversion>',
                        dest='index_format_in_paths',
                        default=':d',
                        help='Python format conversion specification to turn the integer job array index into a file name component, e.g. ":04d" for names like "0001" and "0102"; default is ":d" for names like "1" and "102"')
cli_parser.add_argument('--ignore-templating-errors',
                        dest='should_ignore_templating_errors',
                        action='store_true',
                        default=False,
                        help='do not exit on templating errors, continue trying to generate the rest of the templated content')
cli_parser.add_argument(nargs=argparse.REMAINDER,
                        metavar='<filepath>',
                        dest='input_templates',
                        help='filename of an input template that should be processed')


# Parser CLI arguments:
cli_args = cli_parser.parse_args()


# Fixup logging verbosity if necessary:
logging_level = default_log_level + cli_args.verbose_level - cli_args.quiet_level
if logging_level < 0: logging_level = 0
elif logging_level >= len(log_level_map): logging_level = len(log_level_map) - 1
logging.basicConfig(format='[%(levelname)s] %(message)s', level=log_level_map[logging_level])


# No templates?
if cli_args.input_templates is None or len(cli_args.input_templates) == 0:
    logging.critical('no input templates were provided, so there is nothing to do')
    cli_parser.print_usage()
    sys.exit(errno.EINVAL)
input_templates = list()
for input_template in cli_args.input_templates:
    if input_template == '-' or os.access(input_template, os.R_OK):
        if input_template in input_templates:
            logging.error('the input template %s was specified multiple times', input_template)
            cli_parser.print_usage()
            sys.exit(EINVAL)
        input_templates.append(input_template)
    else:
        logging.error('the input template %s is not readable', input_template)
        sys.exit(errno.EINVAL)
input_template_count = len(input_templates)
logging.info('%d input templates to process', input_template_count)


# No parameters?
if cli_args.parameters is None or len(cli_args.parameters) == 0:
    logging.critical('no parameters were provided, so this is not a parameter scan calculation')
    cli_parser.print_usage()
    sys.exit(errno.EINVAL)
logging.debug('%d initial parameters from CLI', len(cli_args.parameters))

# Drop any empty parameters:
parameters = filter(lambda p: len(p) != 0, [p.strip() for p in cli_args.parameters])
if len(parameters) == 0:
    logging.critical('no parameters were provided, so this is not a parameter scan calculation')
    cli_parser.print_usage()
    sys.exit(errno.EINVAL)
logging.debug('%d parameters after empty filtering', len(cli_args.parameters))


# Process the parameters:
compiled_parameters = list()
logging.debug('compiling parameters into value lists')
for parameter in parameters:
    logging.debug('compiling parameter specification: %s', parameter)

    # Split on the first equals sign:
    parameter = parameter.split('=', 1)

    # Must have two components:
    if len(parameter) < 2:
        logging.error('invalid parameter %s:  no value provided', parameter[0])
        sys.exit(errno.EINVAL)

    # Try to turn the value into a Parameter object:
    try:
        p = Parameter(parameter[0], parameter[1])
        compiled_parameters.append(p)
        logging.info('added parameter %s = %s', p.parameter_name, str(p.value_list))
    except Exception as E:
        logging.error('invalid parameter %s:  %s', parameter[0], str(E))
        sys.exit(errno.EINVAL)


# Are we supposed to write out an indexing catalog?
catalog_stream = None
if cli_args.catalog_path:
    if cli_args.catalog_path == '-':
        catalog_stream = sys.stdout
        logging.debug('indexing catalog will be written to stdout')
    else:
        try:
            catalog_stream = open(cli_args.catalog_path, 'w')
            logging.debug('indexing catalog will be written to %s', cli_args.catalog_path)
        except Exception as E:
            logging.error('unable to open indexing catalog %s for writing: %s', cli_args.catalog_path, str(E))
            sys.exit(errno.EPERM)


# Let's eliminate any single-valued parameters by coallescing them into the
# global variable space; that way we don't need to recurse over them:
global_variables = {}
final_parameters = []
for p in compiled_parameters:
    if len(p.value_list) == 1:
        global_variables[p.parameter_name] = p.value_list[0]
    else:
        final_parameters.append(p)
logging.debug('global variable space after parameter reduction: %s', str(global_variables))


# Create our functions that transforms input paths into output paths, based on
# the flat- versus subdirectory layout that was chosen:
if cli_args.use_flat_layout:
    class TemplatePathHelper(object):
        """
        This variant of TemplatePathHelper appends an underscore and the job array
        index onto the name of the file, sans extension.  For example, the
        template path 'input.xml' with job array index 24 becomes 'input_24.xml'.
        """

        index_to_string_format = '{0' + cli_args.index_format_in_paths + '}'

        @classmethod
        def templatePathToOutputPath(cls, template_path, job_array_index):
            path_components = os.path.split(template_path)
            if template_path == '-':
                return 'stdin_' + cls.index_to_string_format.format(job_array_index)
            filename_components = os.path.splitext(template_path)
            return filename_components[0] + '_' + cls.index_to_string_format.format(job_array_index) + filename_components[1]

else:
    class TemplatePathHelper(object):
        """
        This variant of TemplatePathHelper creates a directory (under the prefix specified
        by the user) with the job array index.  For example, the user provides a prefix of
        './JOBS/RUN1/', the template path is 'input.xml', with job array index 24 the
        path would be './JOBS/RUN1/24/input.xml'.

        The directory tree is created recursively so the prefix needn't be created ahead of
        time by the user.
        """

        index_to_string_format = '{0' + cli_args.index_format_in_paths + '}'
        job_subdirectory_prefix = cli_args.directory_prefix
        initialized_directories = []

        @staticmethod
        def mkdir_p(path, mode=0777):
            if path != '':
                # Split the path into components:
                path_components = os.path.split(path)
                if os.path.exists(path_components[0]):
                    os.mkdir(path, mode)
                else:
                    TemplatePathHelper.mkdir_p(path_components[0], mode)
                    os.mkdir(path, mode)

        @classmethod
        def templatePathToOutputPath(cls, template_path, job_array_index):
            job_subdirectory = cls.job_subdirectory_prefix + cls.index_to_string_format.format(job_array_index)
            if job_subdirectory not in cls.initialized_directories:
                if os.path.exists(job_subdirectory):
                    raise RuntimeError('the job array subdirectory {0} already exists'.format(job_subdirectory))
                TemplatePathHelper.mkdir_p(job_subdirectory)
                cls.initialized_directories.append(job_subdirectory)
            if template_path == '-':
                return os.path.join(job_subdirectory, 'stdin')
            path_components = os.path.split(template_path)
            return os.path.join(job_subdirectory, path_components[1])


# So how many files are we going to generate?
param_combination_count = reduce((lambda a, b: a * b), [len(p.value_list) for p in final_parameters], 1)
logging.info('total parameter combinations %d', param_combination_count)
input_template_count = len(input_templates)
logging.info('will generate %d file(s)', param_combination_count * input_template_count)


# Go ahead and do it!
templating_options = 0
if cli_args.should_ignore_templating_errors:
    templating_options = templating_options | TEMPLATING_OPTIONS_SHOULD_IGNORE_ERRORS;
try:
    job_index = processInputTemplates(input_templates,
                                      global_variables,
                                      final_parameters,
                                      job_array_index=cli_args.array_index,
                                      options=templating_options,
                                      catalog_stream=catalog_stream)
    logging.info('next job array index in sequence would be %d', job_index)
except Exception as E:
    logging.error('failed while generating templated content: %s', str(E))
    sys.exit(1)
